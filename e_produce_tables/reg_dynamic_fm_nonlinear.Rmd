---
author: ""
header-includes:
   - \usepackage{rotating}
   - \usepackage{float}
   - \usepackage{natbib}
   - \usepackage{booktabs}
   - \usepackage{multirow}
geometry: "left=1cm,right=1cm,top=0.9cm,bottom=1.2cm"
output: 
  pdf_document:
    citation_package: natbib
    keep_tex: false
    number_sections: true
#bibliography: ref.bib
link-citations: yes
editor_options: 
  chunk_output_type: console
---

```{r, echo = FALSE, results = 'asis', warning=FALSE, message=FALSE}
rm(list = ls())
library(data.table)
library(dplyr)
library(tidyr)
library(scales)
library(xtable)
library(stringr)
library(pracma)
library(this.path)
setwd(this.path::this.dir())

# read data
data <- readRDS("../tmp/price_impact/regression_dynamic/fm_nonlinear.RDS")[!grepl("OFI_pre_whitened", type)]

# choose lags
data <- data[grepl("_4lag", type)]
data[, type := gsub("_4lag", "", type)]

# select specifications
data <- data[var %in% c("ofi", "ofi_absofi")]
data <- data[spec_idx %in% c(2:3, 16, 22)]
data[, var_lab := ifelse(var == "ofi", "$d_{n,t}$", "$d_{n,t} \\times |d_{n,t}|$")]

# make easier to read
data[var != "ofi", coef := coef / 100]
data[var != "ofi", se := se / 100]

# rank the types
tmp <- unique(data[, .(type, spec_idx)])[order(type, spec_idx)]
tmp[, reg_idx := .I]
data <- merge(data, tmp, by = c("type", "spec_idx"))
rm(tmp)

# add stars
cuts <- abs(qnorm(c(.01, .05, .1) / 2))
data[, abs_tstat := abs(coef / se)]
data[, ss := ifelse(abs_tstat > cuts[1], 3, ifelse(abs_tstat > cuts[2], 2, ifelse(abs_tstat > cuts[3], 1, 0)))]
data[, coef_lab := paste0("$", sprintf("%.2f", coef))]
data[, ss_lab := sapply(data[, ss], function(x) {
  ifelse(x > 0,
    paste0("^{", strcat(rep("*", x)), "}$"),
    "$"
  )
})]
data[, coef_lab := paste0(coef_lab, ss_lab)]
data[, ss_lab := NULL]



est <- dcast(data[, list(var_lab, reg_idx, coef_lab)], var_lab ~ reg_idx, value.var = "coef_lab") %>%
  dplyr::arrange(desc(var_lab)) %>%
  dplyr::mutate(group_id = 100 * row_number(), type = "coef")

se <- dcast(data[, list(var_lab, reg_idx, se)], var_lab ~ reg_idx, value.var = "se") %>%
  dplyr::arrange(desc(var_lab)) %>%
  dplyr::mutate_at(vars(2:ncol(.)), ~ paste0("$(", sprintf("%.2f", round(., 2)), ")$")) %>%
  dplyr::mutate(group_id = 100 * row_number() + 1, type = "se")

tbl <- bind_rows(est, se)
rm(est, se)

# ctrls <- data.table(var_lab = "Predictor controls", t(rep(c("N", "Y", "Y"), 3)))
# ctrls <- rbind(ctrls, data.table(var_lab = "Liquidity controls", t(rep(c("N", "N", "Y"), 3))))
# ctrls[, group_id := 300 + 1:2]
# ctrls[, type := ""]
# names(ctrls) <- names(tbl)
# tbl <- bind_rows(tbl, ctrls)
# rm(ctrls)

# Add control indicators
row1 <- c("Predictor controls", "Y", "Y", "Y", "Y", "Y", "Y", "Y", "Y")
row2 <- c("Liquidity controls", "N", "Y", "Y", "Y", "N", "Y", "Y", "Y")
row3 <- c("Interacted: predictors", "N", "N", "Y", "Y", "N", "N", "Y", "Y")
row4 <- c("Interacted: liquidity", "N", "N", "N", "Y", "N", "N", "N", "Y")

# Combine into a matrix first, then convert to data.table
mat <- rbind(row1, row2, row3, row4)
controls <- as.data.table(mat)
controls[, group_id := 400 + 1:4]
controls[, type := ""]
setnames(controls, names(tbl))
tbl <- bind_rows(tbl, controls)

obs_and_r2 <- unique(data[, list(reg_idx, obs, r2)]) %>%
  mutate(
    obs = comma(obs),
    r2 = paste0("$", sprintf("%.3f", r2), "$")
  ) %>%
  pivot_longer(., -reg_idx) %>%
  pivot_wider(names_from = "reg_idx", values_from = "value") %>%
  dplyr::mutate(name = replace(name, name == "r2", "$R^2$")) %>%
  mutate(name = replace(name, name == "obs", "Obs")) %>%
  rename(var_lab = name) %>%
  mutate(group_id = c(1001, 1002), type = "")

tbl <- bind_rows(tbl, obs_and_r2) %>%
  dplyr::arrange(group_id) %>%
  mutate(var_lab = ifelse(type == "se", "", var_lab)) %>%
  mutate(type = NULL, group_id = NULL)
rm(obs_and_r2)
names(tbl) <- as.character(1:ncol(tbl))

# add col columns
col_names <- data.table(t(as.data.frame(c("", paste0("(", 1:8, ")")))))
names(col_names) <- as.character(1:ncol(col_names))
tbl <- bind_rows(col_names, tbl)
rm(col_names)


align_vactor <- paste0("ll", paste0(rep("c", times = ncol(tbl) - 1), collapse = ""))
x.side <- xtable(tbl, align = align_vactor)


this_add_to_row <- list(
  pos = list(
    -1,
    0, 4, nrow(tbl) - 2, nrow(tbl)
  ),
  command = c(
    "\\hline & \\multicolumn{8}{c}{Dependent variable: stock return $r_{n,t}$} \\\\\n \\hline $d_{n,t}$ = & \\multicolumn{4}{c}{FIT} & \\multicolumn{4}{c}{OFI} \\\\\n \\cmidrule(l){2-5} \\cmidrule(l){6-9}\n",
    rep("\\vspace{5pt}", 3),
    "\\hline \n"
  )
)

print(x.side,
  type = "latex",
  table.placement = "!ht",
  include.rownames = FALSE,
  include.colnames = FALSE,
  tabular.environment = "tabular",
  caption.placement = NULL, # "top", NULL
  hline.after = NULL, # We don't need hline; we use booktabs
  floating = FALSE, # whether \begin{Table} should be created (TRUE) or not (FALSE)
  sanitize.text.function = force, # Important to treat content of first column as latex function
  add.to.row = this_add_to_row
)

to_dir <- "../output/tables/"
dir.create(to_dir, showWarnings = F, recursive = T)
print(x.side,
  type = "latex",
  table.placement = "!ht",
  include.rownames = FALSE,
  include.colnames = FALSE,
  tabular.environment = "tabular",
  caption.placement = NULL, # "top", NULL
  hline.after = NULL, # We don't need hline; we use booktabs
  floating = FALSE, # whether \begin{Table} should be created (TRUE) or not (FALSE)
  sanitize.text.function = force, # Important to treat content of first column as latex function
  add.to.row = this_add_to_row,
  file = paste0(to_dir, "reg_static_fm_nonlinear.tex")
)
```